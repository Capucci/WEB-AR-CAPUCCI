<!DOCTYPE html>
<html>
<head>
   <script>
const VERSION = "4.9.1"; 
// ‚Üë SEMPRE que atualizar modelo ou target,
// s√≥ mude esse n√∫mero
</script>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>

<!-- NECESS√ÅRIO PARA ANIMA√á√ÉO -->
<script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

<style>
body { margin:0; overflow:hidden; }
button {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 15px;
  font-size: 16px;
  z-index: 999;
}
</style>

</head>

<body>

<a-scene
  mindar-image="imageTargetSrc: TargetBalboa.mind;"
  vr-mode-ui="enabled: false"
  device-orientation-permission-ui="enabled: false">

  <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

  <a-entity mindar-image-target="targetIndex: 0" id="target-principal">

    <!-- MODELO -->
    <a-entity
      id="mascote"
      gltf-model="MascoteMana.glb"
      animation-mixer
      position="0 0 0.3"
      rotation="-90 0 0"
      scale="0.7 0.7 0.7">
    </a-entity>

  </a-entity>

  <!-- Elemento de √°udio HTML5 escondido (mais confi√°vel para controle) -->
  <audio id="audioMascote" preload="auto" style="display: none;" loop="false">
    <source src="AudioTrack11" type="audio/mpeg">
    <!-- Substitua "sua-musica.mp3" pelo caminho correto do seu arquivo -->
  </audio>

  <script>
document.addEventListener("DOMContentLoaded", function () {

  const target = document.querySelector('#target-principal');
  
  // Refer√™ncia direta ao elemento de √°udio HTML5
  const audioElement = document.querySelector('#audioMascote');
  
  // Vari√°veis de controle
  let audioUnlocked = false;
  let audioPausedTime = 0;
  let isAudioPlaying = false;
  let wasTargetVisible = false;
  
  // Verificar se o √°udio foi carregado corretamente
  audioElement.addEventListener('loadedmetadata', function() {
    console.log('√Åudio carregado, dura√ß√£o:', audioElement.duration);
  });

  audioElement.addEventListener('error', function(e) {
    console.error('Erro no carregamento do √°udio:', e);
  });

  // üîì Desbloqueia o √°udio no primeiro toque/intera√ß√£o
  function unlockAudio() {
    if (!audioUnlocked) {
      // Toca e pausa imediatamente para desbloquear
      audioElement.play()
        .then(() => {
          audioElement.pause();
          audioElement.currentTime = 0;
          audioUnlocked = true;
          console.log('√Åudio desbloqueado com sucesso!');
        })
        .catch(error => {
          console.log('Aguardando intera√ß√£o do usu√°rio...', error);
        });
    }
  }

  // Tentar desbloquear em v√°rias intera√ß√µes
  document.body.addEventListener("click", unlockAudio);
  document.body.addEventListener("touchstart", unlockAudio);
  
  // Tentar tamb√©m quando a cena carregar
  document.querySelector('a-scene').addEventListener('loaded', function() {
    console.log('Cena carregada, preparando √°udio...');
    unlockAudio();
  });

  // ‚ñ∂ Quando reconhecer o target
  target.addEventListener("targetFound", () => {
    console.log('Target encontrado!');
    wasTargetVisible = true;
    
    // Iniciar anima√ß√£o (j√° deve funcionar automaticamente com animation-mixer)
    
    // Tocar √°udio de onde parou
    if (audioUnlocked) {
      // Se tinha um tempo salvo, continuar de l√°
      if (audioPausedTime > 0) {
        audioElement.currentTime = audioPausedTime;
      }
      
      audioElement.play()
        .then(() => {
          isAudioPlaying = true;
          console.log('√Åudio tocando, tempo:', audioElement.currentTime);
        })
        .catch(error => {
          console.error('Erro ao tocar √°udio:', error);
        });
    } else {
      console.log('√Åudio ainda n√£o desbloqueado');
    }
  });

  // ‚èπ Quando perder o target
  target.addEventListener("targetLost", () => {
    console.log('Target perdido!');
    
    if (isAudioPlaying) {
      // Salvar o tempo atual antes de pausar
      audioPausedTime = audioElement.currentTime;
      audioElement.pause();
      isAudioPlaying = false;
      console.log('√Åudio pausado no tempo:', audioPausedTime);
    }
    
    // Opcional: Parar anima√ß√£o do modelo
    const modelo = document.querySelector('#mascote');
    if (modelo && modelo.components['animation-mixer']) {
      // Para desativar a anima√ß√£o, seria necess√°rio um componente espec√≠fico
      // Mas geralmente o animation-mixer n√£o tem stop f√°cil
    }
  });

  // üîÑ Garantir que quando a p√°gina fechar, nada quebre
  window.addEventListener('beforeunload', function() {
    if (isAudioPlaying) {
      audioElement.pause();
    }
  });

  // ‚è±Ô∏è Monitorar o tempo do √°udio periodicamente para manter sincronizado
  setInterval(() => {
    if (isAudioPlaying && wasTargetVisible) {
      // Atualizar o tempo salvo enquanto toca (backup)
      audioPausedTime = audioElement.currentTime;
    }
  }, 1000);

  // üì± Para debug - mostrar status no console periodicamente
  setInterval(() => {
    if (wasTargetVisible) {
      console.log('Status - Tocando:', isAudioPlaying, 'Tempo:', audioElement.currentTime);
    }
  }, 5000);

});
</script>

<!-- Bot√£o de controle manual para teste -->
<button onclick="toggleAudio()">üîä Testar √Åudio</button>

<script>
// Fun√ß√£o global para teste manual
function toggleAudio() {
  const audio = document.querySelector('#audioMascote');
  if (audio.paused) {
    audio.play();
  } else {
    audio.pause();
  }
}
</script>

</body>
</html>
